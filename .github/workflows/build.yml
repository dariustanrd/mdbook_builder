name: Build and Deploy mdBooks

on:
  push:
    branches: [main]
  schedule:
    # Rebuild daily at 6 AM UTC to pick up upstream changes
    - cron: '0 6 * * *'
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo registry and target
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install mdBook (latest)
        run: |
          mkdir -p $HOME/.local/bin
          # Fetch latest release version from GitHub API
          MDBOOK_VERSION=$(curl -s https://api.github.com/repos/rust-lang/mdBook/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Installing mdBook $MDBOOK_VERSION"
          curl -sSL "https://github.com/rust-lang/mdBook/releases/download/${MDBOOK_VERSION}/mdbook-${MDBOOK_VERSION}-x86_64-unknown-linux-gnu.tar.gz" | tar -xz -C $HOME/.local/bin
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mdbook --version

      - name: Build wrapper mdBook
        run: mdbook build

      - name: Create books directory
        run: mkdir -p book/books

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Build catalog books
        timeout-minutes: 30
        run: |
          # Check if catalog has any books
          BOOK_COUNT=$(yq '.books | length' catalog.yml)
          echo "Found $BOOK_COUNT books in catalog"
          
          if [ "$BOOK_COUNT" -eq 0 ] || [ "$BOOK_COUNT" = "null" ]; then
            echo "No books in catalog, skipping book builds"
            exit 0
          fi
          
          # Process each book
          for i in $(seq 0 $(($BOOK_COUNT - 1))); do
            NAME=$(yq ".books[$i].name" catalog.yml)
            SLUG=$(yq ".books[$i].slug" catalog.yml)
            REPO=$(yq ".books[$i].repo" catalog.yml)
            BRANCH=$(yq ".books[$i].branch // \"main\"" catalog.yml)
            BOOK_PATH=$(yq ".books[$i].path // \".\"" catalog.yml)
            BOOK_TYPE=$(yq ".books[$i].type // \"mdbook\"" catalog.yml)
            
            echo "=========================================="
            echo "Building: $NAME"
            echo "  Slug: $SLUG"
            echo "  Repo: $REPO"
            echo "  Branch: $BRANCH"
            echo "  Path: $BOOK_PATH"
            echo "  Type: $BOOK_TYPE"
            echo "=========================================="
            
            # Clone the repository
            CLONE_DIR="temp_repos/$SLUG"
            git clone --depth 1 --branch "$BRANCH" "$REPO" "$CLONE_DIR" || {
              echo "::warning::Failed to clone $REPO"
              continue
            }
            
            CONTENT_DIR="$CLONE_DIR/$BOOK_PATH"
            
            case "$BOOK_TYPE" in
              "mdbook")
                # Standard mdBook - requires book.toml
                cd "$CONTENT_DIR"
                if [ -f "book.toml" ]; then
                  # Check if book.toml has custom preprocessors that need to be built with Cargo
                  # Look for preprocessor commands that use "cargo run"
                  if grep -q "cargo run" book.toml 2>/dev/null; then
                    echo "Detected custom preprocessors requiring Cargo build..."
                    
                    # Build all Cargo packages in the repo that might be preprocessors
                    if [ -f "Cargo.toml" ]; then
                      echo "Building Cargo workspace/packages..."
                      cargo build --release 2>&1 || {
                        echo "::warning::Failed to build Cargo packages for $NAME, trying without preprocessors"
                      }
                    fi
                    
                    # Check for packages directory (common pattern for mdbook preprocessors)
                    if [ -d "packages" ]; then
                      echo "Building packages directory..."
                      for pkg_toml in packages/*/Cargo.toml; do
                        if [ -f "$pkg_toml" ]; then
                          pkg_dir=$(dirname "$pkg_toml")
                          echo "Building package: $pkg_dir"
                          cargo build --release --manifest-path "$pkg_toml" 2>&1 || true
                        fi
                      done
                    fi
                  fi
                  
                  mdbook build || {
                    echo "::warning::Failed to build $NAME"
                    cd - > /dev/null
                    continue
                  }
                  cd - > /dev/null
                  cp -r "$CONTENT_DIR/book" "book/books/$SLUG"
                  echo "Successfully built mdBook: $NAME"
                else
                  echo "::warning::No book.toml found for $NAME at $BOOK_PATH"
                  cd - > /dev/null
                fi
                ;;
                
              "markdown")
                # Plain markdown repository - auto-generate mdBook wrapper
                echo "Generating mdBook wrapper for markdown content..."
                
                # Create a temporary mdBook structure
                TEMP_BOOK="temp_mdbook_$SLUG"
                mkdir -p "$TEMP_BOOK/src"
                
                # Generate book.toml
                cat > "$TEMP_BOOK/book.toml" << EOF
          [book]
          title = "$NAME"
          authors = []
          language = "en"
          
          [output.html]
          default-theme = "light"
          preferred-dark-theme = "navy"
          EOF
                
                # Start SUMMARY.md
                echo "# Summary" > "$TEMP_BOOK/src/SUMMARY.md"
                echo "" >> "$TEMP_BOOK/src/SUMMARY.md"
                
                # Check for common entry point files
                ENTRY_FILE=""
                for entry in "README.md" "readme.md" "index.md" "INDEX.md"; do
                  if [ -f "$CONTENT_DIR/$entry" ]; then
                    ENTRY_FILE="$entry"
                    break
                  fi
                done
                
                if [ -n "$ENTRY_FILE" ]; then
                  cp "$CONTENT_DIR/$ENTRY_FILE" "$TEMP_BOOK/src/index.md"
                  echo "[Introduction](./index.md)" >> "$TEMP_BOOK/src/SUMMARY.md"
                  echo "" >> "$TEMP_BOOK/src/SUMMARY.md"
                else
                  echo "# $NAME" > "$TEMP_BOOK/src/index.md"
                  echo "" >> "$TEMP_BOOK/src/index.md"
                  echo "Welcome to $NAME" >> "$TEMP_BOOK/src/index.md"
                  echo "[Introduction](./index.md)" >> "$TEMP_BOOK/src/SUMMARY.md"
                  echo "" >> "$TEMP_BOOK/src/SUMMARY.md"
                fi
                
                # Helper function to get title from markdown file
                get_title() {
                  local file="$1"
                  local fallback="$2"
                  local title=$(head -10 "$file" 2>/dev/null | grep -m1 "^#" | sed 's/^#* *//')
                  if [ -z "$title" ]; then
                    echo "$fallback"
                  else
                    echo "$title"
                  fi
                }
                
                # Copy all files first
                find "$CONTENT_DIR" -name "*.md" -type f | while read -r md_file; do
                  rel_path="${md_file#$CONTENT_DIR/}"
                  base_name=$(basename "$md_file")
                  
                  # Skip root entry file and hidden files
                  if [ "$rel_path" = "$ENTRY_FILE" ] || [[ "$rel_path" == .* ]] || [[ "$rel_path" == */.* ]]; then
                    continue
                  fi
                  
                  dir_path=$(dirname "$rel_path")
                  if [ "$dir_path" != "." ]; then
                    mkdir -p "$TEMP_BOOK/src/$dir_path"
                  fi
                  cp "$md_file" "$TEMP_BOOK/src/$rel_path"
                done
                
                # Add root-level markdown files (excluding entry file)
                for md_file in "$CONTENT_DIR"/*.md; do
                  [ -f "$md_file" ] || continue
                  base_name=$(basename "$md_file")
                  
                  # Skip entry file
                  if [ "$base_name" = "$ENTRY_FILE" ]; then
                    continue
                  fi
                  
                  title=$(head -10 "$md_file" 2>/dev/null | grep -m1 "^#" | sed 's/^#* *//')
                  if [ -z "$title" ]; then
                    title="${base_name%.md}"
                  fi
                  echo "- [$title](./$base_name)" >> "$TEMP_BOOK/src/SUMMARY.md"
                done
                
                echo "" >> "$TEMP_BOOK/src/SUMMARY.md"
                
                # Process each directory as a chapter
                for dir in "$CONTENT_DIR"/*/; do
                  [ -d "$dir" ] || continue
                  dir_name=$(basename "$dir")
                  
                  # Skip hidden directories and common non-content dirs
                  [[ "$dir_name" == .* ]] && continue
                  [[ "$dir_name" == "node_modules" ]] && continue
                  [[ "$dir_name" == "__pycache__" ]] && continue
                  
                  # Check if directory has any markdown files
                  md_count=$(find "$dir" -name "*.md" -type f 2>/dev/null | wc -l)
                  [ "$md_count" -eq 0 ] && continue
                  
                  # Create chapter title from directory name
                  chapter_title=$(echo "$dir_name" | sed 's/-/ /g' | sed 's/_/ /g' | sed 's/\b\(.\)/\u\1/g')
                  
                  # Check for README or index in the directory
                  chapter_index=""
                  for entry in "README.md" "readme.md" "index.md" "INDEX.md"; do
                    if [ -f "$dir/$entry" ]; then
                      chapter_index="$entry"
                      # Get title from the README
                      chapter_title=$(head -10 "$dir/$entry" 2>/dev/null | grep -m1 "^#" | sed 's/^#* *//')
                      [ -z "$chapter_title" ] && chapter_title=$(echo "$dir_name" | sed 's/-/ /g' | sed 's/_/ /g' | sed 's/\b\(.\)/\u\1/g')
                      break
                    fi
                  done
                  
                # Add chapter header
                # Track which file is used as chapter header to avoid duplicates
                chapter_header_file=""
                if [ -n "$chapter_index" ]; then
                  echo "- [$chapter_title](./$dir_name/$chapter_index)" >> "$TEMP_BOOK/src/SUMMARY.md"
                  chapter_header_file="$chapter_index"
                else
                  # No index file, use first markdown file or create a placeholder
                  first_md=$(find "$dir" -maxdepth 1 -name "*.md" -type f | sort | head -1)
                  if [ -n "$first_md" ]; then
                    first_md_name=$(basename "$first_md")
                    echo "- [$chapter_title](./$dir_name/$first_md_name)" >> "$TEMP_BOOK/src/SUMMARY.md"
                    chapter_header_file="$first_md_name"
                  else
                    echo "- [$chapter_title]()" >> "$TEMP_BOOK/src/SUMMARY.md"
                  fi
                fi
                
                # Add files in the directory (excluding README/index and the file used as chapter header)
                find "$dir" -maxdepth 1 -name "*.md" -type f | sort | while read -r md_file; do
                  base_name=$(basename "$md_file")
                  
                  # Skip index files (already used as chapter header)
                  [[ "$base_name" =~ ^(README|readme|index|INDEX)\.md$ ]] && continue
                  
                  # Skip the file used as chapter header (when no index file existed)
                  [ "$base_name" = "$chapter_header_file" ] && continue
                  
                  title=$(head -10 "$md_file" 2>/dev/null | grep -m1 "^#" | sed 's/^#* *//')
                  if [ -z "$title" ]; then
                    title="${base_name%.md}"
                  fi
                  echo "  - [$title](./$dir_name/$base_name)" >> "$TEMP_BOOK/src/SUMMARY.md"
                done
                  
                  # Handle subdirectories (one level deep)
                  for subdir in "$dir"/*/; do
                    [ -d "$subdir" ] || continue
                    subdir_name=$(basename "$subdir")
                    [[ "$subdir_name" == .* ]] && continue
                    
                    sub_md_count=$(find "$subdir" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l)
                    [ "$sub_md_count" -eq 0 ] && continue
                    
                    subchapter_title=$(echo "$subdir_name" | sed 's/-/ /g' | sed 's/_/ /g' | sed 's/\b\(.\)/\u\1/g')
                    
                    # Check for index
                    sub_index=""
                    for entry in "README.md" "readme.md" "index.md"; do
                      if [ -f "$subdir/$entry" ]; then
                        sub_index="$entry"
                        subchapter_title=$(head -10 "$subdir/$entry" 2>/dev/null | grep -m1 "^#" | sed 's/^#* *//')
                        [ -z "$subchapter_title" ] && subchapter_title=$(echo "$subdir_name" | sed 's/-/ /g')
                        break
                      fi
                    done
                    
                    if [ -n "$sub_index" ]; then
                      echo "  - [$subchapter_title](./$dir_name/$subdir_name/$sub_index)" >> "$TEMP_BOOK/src/SUMMARY.md"
                    fi
                    
                    find "$subdir" -maxdepth 1 -name "*.md" -type f | sort | while read -r md_file; do
                      base_name=$(basename "$md_file")
                      [[ "$base_name" =~ ^(README|readme|index|INDEX)\.md$ ]] && continue
                      
                      title=$(head -10 "$md_file" 2>/dev/null | grep -m1 "^#" | sed 's/^#* *//')
                      [ -z "$title" ] && title="${base_name%.md}"
                      echo "    - [$title](./$dir_name/$subdir_name/$base_name)" >> "$TEMP_BOOK/src/SUMMARY.md"
                    done
                  done
                  
                  echo "" >> "$TEMP_BOOK/src/SUMMARY.md"
                done
                
                echo "Generated SUMMARY.md:"
                cat "$TEMP_BOOK/src/SUMMARY.md"
                
                # Copy any images and other assets
                for ext in png jpg jpeg gif svg webp; do
                  find "$CONTENT_DIR" -name "*.$ext" -type f 2>/dev/null | while read -r asset; do
                    rel_path="${asset#$CONTENT_DIR/}"
                    dir_path=$(dirname "$rel_path")
                    mkdir -p "$TEMP_BOOK/src/$dir_path"
                    cp "$asset" "$TEMP_BOOK/src/$rel_path"
                  done
                done
                
                # Build the generated mdBook
                cd "$TEMP_BOOK"
                mdbook build || {
                  echo "::warning::Failed to build generated mdBook for $NAME"
                  cd - > /dev/null
                  continue
                }
                cd - > /dev/null
                
                cp -r "$TEMP_BOOK/book" "book/books/$SLUG"
                echo "Successfully built markdown content as mdBook: $NAME"
                ;;
                
              "html")
                # Static HTML site - copy directly
                echo "Copying static HTML content..."
                mkdir -p "book/books/$SLUG"
                cp -r "$CONTENT_DIR"/* "book/books/$SLUG/" || {
                  echo "::warning::Failed to copy HTML content for $NAME"
                  continue
                }
                echo "Successfully copied HTML content: $NAME"
                ;;
                
              *)
                echo "::warning::Unknown type '$BOOK_TYPE' for $NAME, skipping"
                ;;
            esac
          done

      - name: Generate catalog.json
        run: |
          # Convert catalog.yml to JSON for the landing page
          yq -o=json '.' catalog.yml > book/catalog.json
          echo "Generated catalog.json:"
          cat book/catalog.json

      - name: Copy static assets
        run: |
          # Copy JS and CSS to output
          cp -r js book/ 2>/dev/null || true
          cp -r css book/ 2>/dev/null || true

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: book

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
